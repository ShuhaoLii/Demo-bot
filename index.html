<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AutoBricks: Automated Modular Assembly</title>
  <style>
    /* --- æ ¸å¿ƒæ ·å¼ --- */
    :root {
      --primary-color: #0d6efd;
      --bg-color: #f4f7f6;
      --chat-bg: #ffffff;
      --user-msg-bg: #0d6efd;
      --bot-msg-bg: #f0f2f5;
      --system-log-bg: #2d2d2d;
      --system-text: #00ff41;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      /* ç¡®ä¿èƒŒæ™¯å›¾è·¯å¾„å’Œæ–‡ä»¶åæ­£ç¡® */
      background: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url('./fig/bg_tech.png');
      background-size: cover;
      background-position: center;
      background-attachment: fixed;
      display: flex;
      justify-content: center;
      height: 100vh;
    }

    .main-container {
      width: 100%;
      max-width: 1000px;
      margin: 20px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      padding: 20px;
      border-bottom: 1px solid #ddd;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    header h1 { margin: 0; font-size: 1.2rem; color: #333; display: flex; align-items: center; gap: 10px; }
    .badge { background: #28a745; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; text-transform: uppercase; }

    .chat-box { flex: 1; padding: 20px; overflow-y: auto; scroll-behavior: smooth; }

    .message { display: flex; margin-bottom: 20px; animation: fadeIn 0.3s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

    .message.user { justify-content: flex-end; }
    .message.bot { justify-content: flex-start; }

    .avatar { width: 40px; height: 40px; border-radius: 50%; background-size: cover; background-position: center; flex-shrink: 0; }
    
    /* å¼•ç”¨æœ¬åœ°å¤´åƒ */
    .avatar.user-icon { background-image: url('./fig/user_icon.png'); margin-left: 10px; background-color: #e9ecef; }
    .avatar.bot-icon { background-image: url('./fig/bot_icon.png'); margin-right: 10px; background-color: #e3f2fd; }
    
    .content { max-width: 80%; padding: 12px 16px; border-radius: 12px; font-size: 0.95rem; line-height: 1.5; position: relative; }
    .message.user .content { background: var(--user-msg-bg); color: white; border-bottom-right-radius: 2px; }
    .message.bot .content { background: var(--bot-msg-bg); color: #333; border-bottom-left-radius: 2px; }

    .system-log {
      font-family: 'Courier New', Courier, monospace;
      background: var(--system-log-bg);
      color: #e0e0e0;
      padding: 15px;
      border-radius: 8px;
      margin-top: 10px;
      font-size: 0.85rem;
      border-left: 4px solid var(--primary-color);
      box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
    }
    .log-step { margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
    .log-step.success { color: #4cd964; }
    .log-step.warning { color: #ffcc00; }
    .log-step.error { color: #ff3b30; }
    .log-step.processing { color: #5ac8fa; }

    .input-area { padding: 20px; background: #fff; border-top: 1px solid #eee; display: flex; gap: 10px; }
    input[type="text"] { flex: 1; padding: 12px; border: 1px solid #ddd; border-radius: 8px; outline: none; transition: border 0.3s; }
    input[type="text"]:focus { border-color: var(--primary-color); }
    button { padding: 10px 20px; background: var(--primary-color); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: background 0.2s; }
    button:hover { background: #0056b3; }
    button:disabled { background: #ccc; cursor: not-allowed; }

    /* ä¸‹è½½å¡ç‰‡æ ·å¼ */
    .file-card {
      display: flex; align-items: center; background: #fff; border: 1px solid #ddd; padding: 12px; margin-top: 10px; border-radius: 8px;
      cursor: pointer; transition: transform 0.2s; text-decoration: none; color: #333; width: fit-content;
    }
    .file-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); border-color: var(--primary-color); }
    .file-icon { font-size: 1.5rem; margin-right: 12px; }
    .file-info div:first-child { font-weight: 600; margin-bottom: 2px; }
    .file-info div:last-child { font-size: 0.8rem; color: #666; }
  </style>
</head>
<body>

<div class="main-container">
  <header>
    <h1>AutoBricks <span class="badge">v1.0 Demo</span></h1>
    <div style="font-size: 0.9rem; color: #666;">Retrieval-Augmented Modular Assembly</div>
  </header>

  <div class="chat-box" id="chatBox">
    <div class="message bot">
      <div class="avatar bot-icon"></div>
      <div class="content">
        Hello! I am <strong>AutoBricks</strong>. 
        <br><br>
        I can help you build executable Spatio-Temporal forecasting models by retrieving standardized bricks and optimizing them using In-Context Reinforcement Learning.
        <br><br>
        Please describe your task (e.g., <em>"Forecast bike usage in NYC for the next 24 hours"</em>).
      </div>
    </div>
  </div>

  <div class="input-area">
    <input type="text" id="userInput" placeholder="Describe your forecasting task..." onkeypress="handleKeyPress(event)">
    <button id="sendBtn" onclick="sendMessage()">Generate</button>
  </div>
</div>

<script>
  const chatBox = document.getElementById('chatBox');
  const input = document.getElementById('userInput');
  const sendBtn = document.getElementById('sendBtn');

  // --- BikeNYC-I å®šåˆ¶å‰§æœ¬ ---
  const demoScript = {
    trigger: ["bike", "nyc", "è‡ªè¡Œè½¦", "çº½çº¦"], 
    flow: [
      { type: 'text', delay: 200, content: "Received task: <strong>Bike Usage Forecasting in NYC (BikeNYC-I)</strong>. <br>Initializing AutoBricks framework..." },
      
      // Step 1: Retrieval & Analysis
      [cite_start]// LocalCNN [cite: 180] is suitable for Grid-based spatial modeling.
      { type: 'log', delay: 800, content: [
        { status: 'processing', text: "Analyzing Topological Constraints..." },
        { status: 'success', text: "Identified Topology: <strong>Grid-based</strong> (Euclidean Coordinates detected)." },
        { status: 'processing', text: "Querying Brick Registry & History Logs..." },
        { status: 'success', text: "Retrieved Spatial Anchors: <span style='color:#fff'>[LocalCNN, ConvLSTM, ST-ResNet]</span>" },
        { status: 'success', text: "Retrieved Temporal Anchors: <span style='color:#fff'>[AttentiveLSTM, PyramidalConvGRU]</span>" },
        { status: 'warning', text: "<strong>Constraint Applied:</strong> Graph operators (GCN/GAT) suppressed for Grid topology." }
      ]},

      // Step 2: Assembly & Optimization
      // Combining Spatial (LocalCNN) and Temporal (AttentiveLSTM) components.
      { type: 'text', delay: 1200, content: "Constructing Directed Acyclic Graph (DAG) based on retrieved anchors and accuracy-first strategy..." },
      
      { type: 'log', delay: 1000, content: [
        { status: 'processing', text: "<strong>Trial Assembly:</strong> { Spatial: LocalCNN, Temporal: AttentiveLSTM }" },
        { status: 'processing', text: "Hyperparameter Search: Hidden Dim=128, Spatial Layers=4, Temporal Layers=2" },
        { status: 'success', text: "Syntax Check: PASSED" },
        // Results referencing user provided data
        { status: 'success', text: "<strong>Performance Est. (MAE): 1.229</strong> (Superior to Baseline 1.593)" }, 
        { status: 'success', text: "Model Complexity: 0.6074M Parameters (Efficient)" }
      ]},

      // Step 3: Final Output
      { type: 'final', delay: 800, content: "Optimization Complete. The model <strong>AutoBricks-BikeNYC-V1</strong> has been generated." }
    ]
  };

  function handleKeyPress(e) {
    if (e.key === 'Enter') sendMessage();
  }

  // --- å‘é€æ¶ˆæ¯é€»è¾‘ (åŒ…å«é”™è¯¯å¤„ç†ï¼Œé˜²æ­¢æŒ‰é’®å¡æ­») ---
  async function sendMessage() {
    const text = input.value.trim();
    if (!text) return;

    // 1. ä¸Šå±ç”¨æˆ·æ¶ˆæ¯
    addMessage('user', text);
    input.value = '';
    
    // 2. é”å®šæŒ‰é’®
    input.disabled = true;
    sendBtn.disabled = true;
    sendBtn.innerText = "Generating...";
    input.style.cursor = "wait";
    sendBtn.style.background = "#ccc";

    try {
      // 3. æ‰§è¡Œé€»è¾‘
      await processAutoBricksLogic(text);
    } catch (e) {
      console.error(e); // åœ¨æ§åˆ¶å°æ‰“å°é”™è¯¯
      addMessage('bot', `<span style="color:red">Error: ${e.message}</span>`);
    } finally {
      // 4. è§£é”æŒ‰é’® (æ— è®ºæˆåŠŸå¤±è´¥)
      input.disabled = false;
      sendBtn.disabled = false;
      sendBtn.innerText = "Generate";
      input.style.cursor = "text";
      sendBtn.style.background = "#0d6efd";
      setTimeout(() => input.focus(), 100);
    }
  }

  async function processAutoBricksLogic(userText) {
    const lowerText = userText.toLowerCase();
    const isTriggered = demoScript.trigger.some(keyword => lowerText.includes(keyword));
    
    if (isTriggered) {
      for (const step of demoScript.flow) {
        await sleep(step.delay || 1000);
        
        if (step.type === 'text') {
          addMessage('bot', step.content);
        } else if (step.type === 'log') {
          const logMsg = createBotMessageElement();
          logMsg.contentDiv.style.background = 'transparent';
          logMsg.contentDiv.style.padding = '0';
          logMsg.contentDiv.appendChild(createSystemLog(step.content));
          chatBox.appendChild(logMsg.container);
          scrollToBottom();
        } else if (step.type === 'final') {
          const finalMsgDiv = addMessage('bot', step.content);
          appendDownloadCards(finalMsgDiv);
        }
      }
    } else {
      await sleep(600);
      addMessage('bot', "I received your request. For this demo, please try asking about <em>'BikeNYC'</em> or <em>'New York Bike Usage'</em> to see the full workflow simulation.");
    }
  }

  function addMessage(role, htmlContent) {
    const msgEl = role === 'bot' ? createBotMessageElement() : createUserMessageElement();
    msgEl.contentDiv.innerHTML = htmlContent;
    chatBox.appendChild(msgEl.container);
    scrollToBottom();
    return msgEl.contentDiv;
  }

  function createBotMessageElement() {
    const container = document.createElement('div');
    container.className = 'message bot';
    container.innerHTML = `<div class="avatar bot-icon"></div><div class="content"></div>`;
    return { container: container, contentDiv: container.querySelector('.content') };
  }

  function createUserMessageElement() {
    const container = document.createElement('div');
    container.className = 'message user';
    container.innerHTML = `<div class="content"></div><div class="avatar user-icon"></div>`;
    return { container: container, contentDiv: container.querySelector('.content') };
  }

  function createSystemLog(logLines) {
    const logDiv = document.createElement('div');
    logDiv.className = 'system-log';
    let html = '';
    logLines.forEach(line => {
      let icon = 'â€¢';
      if (line.status === 'success') icon = 'âœ”';
      if (line.status === 'error') icon = 'âœ–';
      if (line.status === 'warning') icon = 'âš ';
      if (line.status === 'processing') icon = 'âš¡';
      html += `<div class="log-step ${line.status}"><span>${icon}</span> ${line.text}</div>`;
    });
    logDiv.innerHTML = html;
    return logDiv;
  }

  // --- ç”Ÿæˆ BikeNYC ä¸“å±ä¸‹è½½å¡ç‰‡ ---
  function appendDownloadCards(parentDiv) {
    const container = document.createElement('div');
    container.style.marginTop = "15px";
    container.style.display = "flex";
    container.style.gap = "10px";
    container.style.flexWrap = "wrap";

    // Card 1: Config Yaml
    const configCard = document.createElement('a');
    configCard.className = 'file-card';
    const configContent = `dataset: BikeNYC\ntopology: Grid\nmodel:\n  spatial: LocalCNN\n  temporal: AttentiveLSTM\n  layers: [4, 2]\n  hidden_dim: 128\nmetrics:\n  MAE: 1.229\n  Params: 0.6074M`;
    configCard.href = 'data:text/yaml;charset=utf-8,' + encodeURIComponent(configContent);
    configCard.download = 'config_bikenyc.yaml';
    configCard.innerHTML = `
      <span class="file-icon">âš™ï¸</span>
      <div class="file-info">
        <div>config.yaml</div>
        <div>Model Hyperparameters</div>
      </div>
    `;

    // Card 2: Python Code
    const codeCard = document.createElement('a');
    codeCard.className = 'file-card';
    const pyContent = `import torch\nimport torch.nn as nn\n\n# AutoBricks Generated Model for BikeNYC\nclass AutoBricksModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        # Spatial Brick: LocalCNN (Selected for Grid Topology)\n        self.spatial = LocalCNN(in_channels=2, out_channels=128, layers=4)\n        \n        # Temporal Brick: AttentiveLSTM (Selected for Sequence)\n        self.temporal = AttentiveLSTM(hidden_dim=128, layers=2)\n        \n        self.fusion = nn.Linear(128, 1)\n\n    def forward(self, x):\n        x = self.spatial(x)\n        x = self.temporal(x)\n        return self.fusion(x)`;
    codeCard.href = 'data:text/x-python;charset=utf-8,' + encodeURIComponent(pyContent);
    codeCard.download = 'model_bikenyc.py';
    codeCard.innerHTML = `
      <span class="file-icon">ğŸ</span>
      <div class="file-info">
        <div>model.py</div>
        <div>Executable PyTorch Code</div>
      </div>
    `;

    container.appendChild(configCard);
    container.appendChild(codeCard);
    parentDiv.appendChild(container);
    scrollToBottom();
  }

  function scrollToBottom() { chatBox.scrollTop = chatBox.scrollHeight; }
  function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
  window.onload = () => input.focus();

</script>
</body>
</html>